<!-- Email popup for Contact button -->
<div id="email-popup" style="display:none;position:fixed;z-index:2000;left:50%;transform:translateX(-50%);bottom:120px;background:rgba(0,0,0,0.92);color:#fff;padding:10px 24px;border-radius:10px;font-size:1.1em;font-family:sans-serif;box-shadow:0 2px 12px #0006;pointer-events:none;">ArtNomadGallery@gmail.com</div>
<script>
// Show email popup above Contact button on hover (desktop) and tap/click (touch/mobile)
document.addEventListener('DOMContentLoaded', function() {
  var contactLink = document.querySelector('a.menu-link[href="#contact"]');
  var emailPopup = document.getElementById('email-popup');
  if (contactLink && emailPopup) {
    function showPopup() {
      var rect = contactLink.getBoundingClientRect();
      emailPopup.style.left = (rect.left + rect.width/2) + 'px';
      emailPopup.style.bottom = (window.innerHeight - rect.top + 12) + 'px';
      emailPopup.style.display = 'block';
    }
    function hidePopup() {
      emailPopup.style.display = 'none';
    }
    contactLink.addEventListener('mouseenter', showPopup);
    contactLink.addEventListener('mouseleave', hidePopup);
    // Touch/click support
    contactLink.addEventListener('touchstart', function(e) {
      e.preventDefault();
      if (emailPopup.style.display === 'block') {
        hidePopup();
      } else {
        showPopup();
      }
    });
    contactLink.addEventListener('click', function(e) {
      // Only trigger on touch devices or if popup is not visible
      if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
        e.preventDefault();
        if (emailPopup.style.display === 'block') {
          hidePopup();
        } else {
          showPopup();
        }
      }
    });
    // Hide popup if user taps elsewhere
    document.addEventListener('touchstart', function(e) {
      if (!contactLink.contains(e.target) && !emailPopup.contains(e.target)) {
        hidePopup();
      }
    });
    document.addEventListener('click', function(e) {
      if (!contactLink.contains(e.target) && !emailPopup.contains(e.target)) {
        hidePopup();
      }
    });
  }
});
</script>
// No highlight on ARTWorks mesh when hovering Artworks menu link; original behavior restored
// ...existing code...

// Click on ARTWorks mesh no longer does anything; hover effect remains only
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>GLB Viewer (artnomad.glb)</title>
  <style>
  /* removed stray JS comment */
  /* removed misplaced JS variable */
  body { margin:0; background:#222222; }
      #msg { color:#fff; position:absolute; top:10px; left:10px; z-index:2; }
    </style>
</head>
<body>

<div id="msg">Loading artnomad.glb...</div>

<nav id="main-menu" style="position:fixed;bottom:74px;left:50%;transform:translateX(-50%);z-index:1003;display:flex;gap:32px;background:rgba(255,255,255,0.92);border-radius:16px 16px 24px 24px;padding:10px 32px 8px 32px;box-shadow:0 4px 24px #0002;backdrop-filter:blur(2px);font-family:sans-serif;">
  <a href="magazine_rack.html" class="menu-link">Artworks</a>
  <a href="#about" class="menu-link">About</a>
  <a href="#music" class="menu-link">Music</a>
  <a href="#travel" class="menu-link">Travel</a>
  <a href="#contact" class="menu-link">Contact</a>
</nav>
<style>
.menu-link {
  color: #222;
  text-decoration: none;
  font-size: 1.13em;
  font-weight: 600;
  letter-spacing: 0.04em;
  padding: 2px 10px 2px 10px;
  border-radius: 8px;
  transition: background 0.18s, color 0.18s;
}
.menu-link:hover {
  background: #e0f7fa;
  color: #00796b;
}
</style>
<div id="social-icons" style="position:fixed;bottom:24px;left:50%;transform:translateX(-50%);z-index:1002;display:flex;gap:18px;">
  <a href="#" tabindex="-1" title="YouTube" class="social-icon youtube" style="pointer-events:none;">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="#000"><path d="M23.498 6.186a2.994 2.994 0 0 0-2.108-2.116C19.204 3.5 12 3.5 12 3.5s-7.204 0-9.39.57A2.994 2.994 0 0 0 .502 6.186C0 8.37 0 12 0 12s0 3.63.502 5.814a2.994 2.994 0 0 0 2.108 2.116C4.796 20.5 12 20.5 12 20.5s7.204 0 9.39-.57a2.994 2.994 0 0 0 2.108-2.116C24 15.63 24 12 24 12s0-3.63-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>
  </a>
  <a href="#" tabindex="-1" title="Instagram" class="social-icon instagram" style="pointer-events:none;">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="#000"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 1.366.062 2.633.334 3.608 1.308.974.974 1.246 2.242 1.308 3.608.058 1.266.07 1.646.07 4.85s-.012 3.584-.07 4.85c-.062 1.366-.334 2.633-1.308 3.608-.974.974-2.242 1.246-3.608 1.308-1.266.058-1.646.07-4.85.07s-3.584-.012-4.85-.07c-1.366-.062-2.633-.334-3.608-1.308-.974-.974-1.246-2.242-1.308-3.608C2.175 15.647 2.163 15.267 2.163 12s.012-3.584.07-4.85c.062-1.366.334-2.633 1.308-3.608C4.515 2.567 5.783 2.295 7.149 2.233 8.415 2.175 8.795 2.163 12 2.163zm0-2.163C8.741 0 8.332.013 7.052.072 5.771.131 4.659.363 3.678 1.344 2.697 2.325 2.465 3.437 2.406 4.718 2.347 5.998 2.334 6.407 2.334 12c0 5.593.013 6.002.072 7.282.059 1.281.291 2.393 1.272 3.374.981.981 2.093 1.213 3.374 1.272C8.332 23.987 8.741 24 12 24s3.668-.013 4.948-.072c1.281-.059 2.393-.291 3.374-1.272.981-.981 1.213-2.093 1.272-3.374.059-1.28.072-1.689.072-7.282 0-5.593-.013-6.002-.072-7.282-.059-1.281-.291-2.393-1.272-3.374C19.341.363 18.229.131 16.948.072 15.668.013 15.259 0 12 0zm0 5.838a6.162 6.162 0 1 0 0 12.324 6.162 6.162 0 0 0 0-12.324zm0 10.162a3.999 3.999 0 1 1 0-7.998 3.999 3.999 0 0 1 0 7.998zm6.406-11.845a1.44 1.44 0 1 0 0 2.88 1.44 1.44 0 0 0 0-2.88z"/></svg>
  </a>
  <a href="#" tabindex="-1" title="Facebook" class="social-icon facebook" style="pointer-events:none;">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="#000"><path d="M22.675 0h-21.35C.595 0 0 .592 0 1.326v21.348C0 23.408.595 24 1.326 24H12.82v-9.294H9.692v-3.622h3.127V8.413c0-3.1 1.893-4.788 4.659-4.788 1.325 0 2.463.099 2.797.143v3.24l-1.918.001c-1.504 0-1.797.715-1.797 1.763v2.313h3.587l-.467 3.622h-3.12V24h6.116C23.406 24 24 23.408 24 22.674V1.326C24 .592 23.406 0 22.675 0"/></svg>
  </a>
</div>
<style>
.social-icon {
  display:inline-block;
  width:38px;height:38px;
  background:#111;
  border-radius:50%;
  box-shadow:0 2px 8px #0006;
  display:flex;align-items:center;justify-content:center;
  transition:box-shadow .2s, background .2s;
}
.social-icon svg {
  transition: fill .2s;
}
.social-icon.youtube:hover {
  background:#fff;
  box-shadow:0 0 16px 0 #ff0000cc,0 2px 8px #0006;
}
.social-icon.youtube:hover svg {
  fill: #FF0000;
}
.social-icon.instagram:hover {
  background:#fff;
  box-shadow:0 0 16px 0 #c13584cc,0 2px 8px #0006;
}
.social-icon.instagram:hover svg {
  fill: #C13584;
}
.social-icon.facebook:hover {
  background:#fff;
  box-shadow:0 0 16px 0 #1877f3cc,0 2px 8px #0006;
}
.social-icon.facebook:hover svg {
  fill: #1877F3;
}
</style>

<div id="mesh-labels" style="position:absolute;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:23;"></div>
<script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
<script>

const msg = document.getElementById('msg');
function setMsg(t){ msg.innerHTML = t; }
const renderer = new THREE.WebGLRenderer({antialias:true});
document.body.appendChild(renderer.domElement);
renderer.setClearColor(0x222222);
renderer.setSize(window.innerWidth, window.innerHeight);
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 1000);
// Camera animation: start at bird's eye, animate to main view
const cameraStart = { x: 0, y: 30, z: 0 };
const cameraEnd = { x: 5, y: 2, z: 12 };
const targetStart = { x: 0, y: 1, z: 0 };
const targetEnd = { x: 0, y: 1, z: 0 };
camera.position.set(cameraStart.x, cameraStart.y, cameraStart.z);
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08; // Lower = smoother, higher = snappier
controls.rotateSpeed = 0.7; // Lower = smoother
controls.enableZoom = false; // Disable zoom with mouse scroll
controls.target.set(targetStart.x, targetStart.y, targetStart.z);
controls.update();

// Add a spotlight that follows the mouse
const spotLight = new THREE.SpotLight(0xffffff, 0.45, 0, Math.PI/8, 0.2, 1);
spotLight.position.set(0, 8, 8);
spotLight.castShadow = true;
spotLight.shadow.mapSize.width = 1024;
spotLight.shadow.mapSize.height = 1024;
spotLight.shadow.bias = -0.0005;
scene.add(spotLight);
scene.add(spotLight.target);


// Subtle idle animation for spotlight at start position
let lampIdleStart = performance.now();

function animateLampIdle(ts) {
  const t = ((ts || performance.now()) - lampIdleStart) / 1000;
  // Subtle up/down and tiny left/right motion
  spotLight.position.x = Math.sin(t * 0.5) * 0.3;
  spotLight.position.y = 8 + Math.cos(t * 0.7) * 0.2;
  spotLight.position.z = 8 + Math.sin(t * 0.3) * 0.2;
  spotLight.target.position.set(0, 1, 0);
  requestAnimationFrame(animateLampIdle);
}
animateLampIdle();
let cameraAnimTime = 0;
let cameraAnimDuration = 2.5; // seconds
let cameraHoldDuration = 1.8; // seconds to hold at start before panning
let cameraAnimating = true;
scene.add(new THREE.AmbientLight(0xffffff, 1.0));
let model = null;
let allMeshes = [];
let mixer = null;
let meshAnimAction = null;
let orbitingMeshes = [];
let orbitStartTime = null;
// Mesh label overlay
const meshLabelDiv = document.createElement('div');
meshLabelDiv.style.position = 'absolute';
meshLabelDiv.style.color = '#fff';
meshLabelDiv.style.background = 'rgba(0,0,0,0.7)';
meshLabelDiv.style.padding = '2px 6px';
meshLabelDiv.style.borderRadius = '4px';
meshLabelDiv.style.pointerEvents = 'none';
meshLabelDiv.style.display = 'none';
meshLabelDiv.style.fontFamily = 'sans-serif';
meshLabelDiv.style.fontSize = '14px';
meshLabelDiv.style.zIndex = 24;
document.body.appendChild(meshLabelDiv);
if (typeof THREE.GLTFLoader !== 'function') { setMsg('GLTFLoader not available'); throw new Error('GLTFLoader not available'); }
const loader = new THREE.GLTFLoader();
loader.load('artnomad.glb', gltf => {
  model = gltf.scene;
  let meshNames = [];
  model.traverse(obj => {
    if (obj.isMesh) {
      // ...existing code...
// Show 'ARTWorks' above 'geometry' mesh on hover, not mesh name
renderer.domElement.addEventListener('mousemove', e => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  let meshHovered = false;
  if (model && allMeshes.length) {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(allMeshes, true);
    if (intersects.length > 0) {
      const mesh = intersects[0].object;
        // Remove mesh label display on hover
        meshLabelDiv.style.display = 'none';
      // ...existing highlight/animation code...
    } else {
      meshLabelDiv.style.display = 'none';
    }
  }
  // ...existing animation stop code...
});


      meshNames.push(obj.name);
      if (obj.name === 'MESH') meshAnimMesh = obj;
      obj.castShadow = true;
      obj.receiveShadow = true;
      if (obj.material && obj.material.isMeshStandardMaterial) {
        // Make mesh named 'Text' or 'MESH' always lit, no hover effect
        if (obj.name === 'MESH' || obj.name === 'Text') {
          obj.material.color = new THREE.Color('#fffbe6');
          obj.material.emissive = new THREE.Color('#ffe066');
          obj.material.emissiveIntensity = 4.0;
          obj.material.metalness = 0.3;
          obj.material.roughness = 0.12;
          obj.material.opacity = 1.0;
          obj.material.transparent = false;
          if ('clearcoat' in obj.material) {
            obj.material.clearcoat = 0.5;
            obj.material.clearcoatRoughness = 0.08;
          }
        } else if (/^(mesh[_]?|Mesh[_]?)[0-7]$/.test(obj.name)) {
          orbitingMeshes.push(obj);
          obj.material.color = new THREE.Color('#fffbe6');
          obj.material.emissive = new THREE.Color('#ffe066');
          obj.material.emissiveIntensity = 4.0;
          obj.material.metalness = 0.3;
          obj.material.roughness = 0.12;
          obj.material.opacity = 1.0;
          obj.material.transparent = false;
          if ('clearcoat' in obj.material) {
            obj.material.clearcoat = 0.5;
            obj.material.clearcoatRoughness = 0.08;
          }
        } else {
          obj.material.emissive = new THREE.Color(0x222222);
          obj.material.emissiveIntensity = 0.5;
        }
      }
      allMeshes.push(obj);
    }
  });
  if (gltf.animations && gltf.animations.length && meshAnimMesh) {
    mixer = new THREE.AnimationMixer(meshAnimMesh);
    meshAnimAction = mixer.clipAction(gltf.animations[0]);
    meshAnimAction.loop = THREE.LoopRepeat;
    meshAnimAction.clampWhenFinished = false;
    meshAnimAction.enabled = false;
    meshAnimAction.stop(); // Ensure not playing by default
    meshAnimAction.paused = true;
  }
  console.log('Loaded mesh names:', meshNames);
  scene.add(model);
  setMsg('Loaded artnomad.glb');
}, undefined, err => {
  setMsg('Failed to load: ' + (err.message||err));
});

// Raycaster for hover highlight on all meshes
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let lastHighlighted = null;
renderer.domElement.addEventListener('mousemove', e => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  let meshHovered = false;
  if (model && allMeshes.length) {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(allMeshes, true);
    if (intersects.length > 0) {
      const mesh = intersects[0].object;
  // Only show hover effect for meshes NOT Mesh0-Mesh7, mesh_0-mesh_7, 'MESH', or 'Text'
  if (!/^(mesh[_]?|Mesh[_]?)[0-7]$/.test(mesh.name) && mesh.name !== 'MESH' && mesh.name !== 'Text') {
        if (lastHighlighted && lastHighlighted !== mesh) {
          // Only reset if not a lit mesh
          if (!/^(mesh[_]?|Mesh[_]?)[0-7]$/.test(lastHighlighted.name)) {
            lastHighlighted.material.emissive = new THREE.Color(0x222222);
            lastHighlighted.material.emissiveIntensity = 0.5;
          }
        }
        mesh.material.emissive = new THREE.Color(0xffffff);
        mesh.material.emissiveIntensity = 2.0;
        lastHighlighted = mesh;
        // Show mesh name label above hovered mesh
        meshLabelDiv.textContent = mesh.name || 'unnamed';
        meshLabelDiv.style.display = 'block';
        // Project mesh position to screen
        const pos = mesh.getWorldPosition(new THREE.Vector3());
        pos.project(camera);
        meshLabelDiv.style.left = ((pos.x * 0.5 + 0.5) * window.innerWidth + 8) + 'px';
        meshLabelDiv.style.top = ((-pos.y * 0.5 + 0.5) * window.innerHeight - 24) + 'px';
      } else {
        // For Mesh0-Mesh7, mesh_0-mesh_7, 'MESH', and 'Text', always keep them lit and do not change on hover
        meshLabelDiv.style.display = 'none';
      }
      // Animation for mesh named 'MESH' on hover
      if (meshAnimMesh && mesh === meshAnimMesh && meshAnimAction) {
        if (!meshAnimAction.isRunning()) {
          meshAnimAction.reset();
          meshAnimAction.enabled = true;
          meshAnimAction.paused = false;
          meshAnimAction.play();
        }
        meshHovered = true;
      }
    } else if (lastHighlighted) {
      if (!/^(mesh[_]?|Mesh[_]?)[0-7]$/.test(lastHighlighted.name) && lastHighlighted.name !== 'MESH' && lastHighlighted.name !== 'Text') {
        lastHighlighted.material.emissive = new THREE.Color(0x222222);
        lastHighlighted.material.emissiveIntensity = 0.5;
      }
      lastHighlighted = null;
      meshLabelDiv.style.display = 'none';
    } else {
      meshLabelDiv.style.display = 'none';
    }
  }
  // Stop animation if not hovered
  if (meshAnimAction && !meshHovered) {
    if (meshAnimAction.isRunning()) {
      meshAnimAction.paused = true;
      meshAnimAction.enabled = false;
    }
  }
});

// Mouse to spotlight (optional, if you want a moving light)
// Uncomment below if you want a spotlight following the mouse
// const spotLight = new THREE.SpotLight(0xffffff, 2.0, 0, Math.PI/8, 0.2, 1);
// spotLight.position.set(0, 5, 2);
// spotLight.castShadow = true;
// spotLight.shadow.mapSize.width = 1024;
// spotLight.shadow.mapSize.height = 1024;
// spotLight.shadow.bias = -0.0005;
// scene.add(spotLight);
// scene.add(spotLight.target);
// renderer.domElement.addEventListener('mousemove', e => {
//   const x = (e.clientX / window.innerWidth) * 2 - 1;
//   const y = -(e.clientY / window.innerHeight) * 2 + 1;
//   spotLight.position.x = x * 3;
//   spotLight.position.z = 2 + y * 3;
//   spotLight.target.position.set(0, 1, 0);
// });
window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
function animate(ts){
  // Camera animation at start
  if (cameraAnimating) {
    if (!animate.startTime) animate.startTime = ts || performance.now();
    cameraAnimTime = ((ts || performance.now()) - animate.startTime) / 1000;
    if (cameraAnimTime < cameraHoldDuration) {
      // Hold at start position and target
      camera.position.set(cameraStart.x, cameraStart.y, cameraStart.z);
      controls.target.set(targetStart.x, targetStart.y, targetStart.z);
      controls.update();
      controls.enabled = false;
    } else {
      // Begin panning after hold
      let panTime = cameraAnimTime - cameraHoldDuration;
      let t = Math.min(1, panTime / cameraAnimDuration);
      // Ease in-out
      t = t < 0.5 ? 2*t*t : -1+(4-2*t)*t;
      camera.position.x = cameraStart.x + (cameraEnd.x - cameraStart.x) * t;
      camera.position.y = cameraStart.y + (cameraEnd.y - cameraStart.y) * t;
      camera.position.z = cameraStart.z + (cameraEnd.z - cameraStart.z) * t;
      controls.target.x = targetStart.x + (targetEnd.x - targetStart.x) * t;
      controls.target.y = targetStart.y + (targetEnd.y - targetStart.y) * t;
      controls.target.z = targetStart.z + (targetEnd.z - targetStart.z) * t;
      controls.update();
      if (panTime >= cameraAnimDuration) {
        cameraAnimating = false;
        camera.position.set(cameraEnd.x, cameraEnd.y, cameraEnd.z);
        controls.target.set(targetEnd.x, targetEnd.y, targetEnd.z);
        controls.enabled = true;
      } else {
        controls.enabled = false;
      }
    }
  }
  // ...existing code...
  // (Orbit animation removed; meshes remain static)
  // Animate mesh named 'MESH' if mixer exists
  if (mixer) mixer.update(0.016);
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
